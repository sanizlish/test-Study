# Z函数（扩展KMP）
## 定义
> 对于一个长度为`n`的字符串，定义函数`z[i]`表示`s`和`s[i, n-1]`（即以`s[i]`开头的后缀）的最长公共前缀（LCP）的长度，则`z`被称为`s`的**Z函数**，特别的`s[0]=0`

## 线性算法
> 对于`i`，区间`[i, i+z[i]-1]`是i的**匹配段**，也叫Z-box  
> 维护右端点靠右的匹配段`[l,r]`。`s[l,r]`是`s`的前缀。在计算`z[i]`时保证`l<=i`。初始`l=r=0`。
>
> 在计算`z[i]`的过程中：  
> * 如果$i\leq r$，那么根据`[l,r]`的定义有`s[i,r]=s[i-l,r-l]`，因此$z[i]\geq min(z[i-l],r-i+1)$
>   * 若$z[i-l]<r-i+1$，则$z[i]=z[i-l]$
>   * 否则$z[i-l]\geq r-i+1$，令$z[i]=r-i+1$，然后暴力枚举下一个字符
> * 如果$i>r$，我们直接按照朴素方法，从$s[i]$开始比较，暴力求出$z[i]$
> * 求出$z[i]$后，如果$i+z[i]-1>r$需要更新$[l,r]$即令$l=i, r=i+z[i]-1$
>

> 在$i\leq r$ (必定是$i\geq l$，$l$更新的是之前i的位置)时候，后面类似于马拉车算法。$s[l,r]=s[0,r-l]$，所以现在$s[i,r]=s[i^{'},r-l]$，这个$i^{'}$是映射到$s[0,r-l]$这一段，所以$i^{'}=i-l$。  
> 说明$Z[i]\geq min(Z[i^{'}],r-i+1)$，因为$Z[i^{'}]$的长度可能超过了我们所映射的长度，我们只知道$s[i,r]=s[i^{'},r-l]$，如果太长超过了$r-l$，后面的值我们就不一定相等了。
>
```c++
vector<int> z_function(string s) {
  int n = (int)s.length();
  vector<int> z(n);
  for (int i = 1, l = 0, r = 0; i < n; ++i) {
    if (i <= r && z[i - l] < r - i + 1) {
      z[i] = z[i - l];
    } else {
      z[i] = max(0, r - i + 1);
      while (i + z[i] < n && s[z[i]] == s[i + z[i]]) ++z[i];
    }
    if (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;
  }
  return z;
}
```